.\" -*- mode: nroff -*-
.\" Generated by 'click-elem2man' from '../elements/ip/iproutetable.hh:8'
.de M
.IR "\\$1" "(\\$2)\\$3"
..
.de RM
.RI "\\$1" "\\$2" "(\\$3)\\$4"
..
.TH "IPROUTETABLE" 7click "12/Oct/2017" "Click"
.SH "NAME"
IPRouteTable \- Click element;
IP routing table superclass
.SH "SYNOPSIS"
\fBIPRouteTable\fR

.SH "DESCRIPTION"
\fBIPRouteTable\fR defines an interface useful for implementing IPv4 route lookup
elements. It parses configuration strings -- see 
.M LinearIPLookup 7
for an example
-- and calls virtual functions to add the resulting routes. A default \f(CWpush\fR
function uses those virtual functions to look up routes and output packets
accordingly. There are also some functions useful for implementing handlers.
.PP

.SH "PERFORMANCE"
Click provides several elements that implement all or part of the \fBIPRouteTable\fR
interface.  Marko Zec has compared their performance, in terms of lookup speed
and memory size, for full BGP feeds; here are the results.
.PP
Methodology: 2.8GHz Pentium P4 CPU, 521K L2 cache, FreeBSD 4.10, userspace
Click.  
.M RangeIPLookup 7
has two lookup tables, the larger of which is used only
at update time.  The "warm cache" numbers perform the same lookup several
times in a loop to populate the cache; only the last lookup's performance is
reported.
.PP
.nf
\&              ICSI BGP dump, 150700 routes, 2 next-hops
\& 
\&         Element      | cycles  | lookups | setup | lookup
\&                      | /lookup | /sec    | time  | tbl. size
\&     -----------------+---------+---------+-------+----------------
\&     RadixIPLookup    |   1025  |  2.73M  | 0.59s |  5.8 MB
\&     DirectIPLookup   |    432  |  6.48M  | 0.74s | 33   MB
\&     RangeIPLookup    |    279  | 10.0 M  | 0.83s |  0.21MB (+33MB)
\&       " (warm cache) |     44  | 63.6 M  |   "   |    "       "
\& 
\&           routeviews.org dump, 167000 routes, 52 nexthops
\& 
\&         Element      | cycles  | lookups | setup | lookup
\&                      | /lookup | /sec    | time  | tbl. size
\&     -----------------+---------+---------+-------+----------------
\&     RadixIPLookup    |   1095  |  2.55M  | 0.67s |  6.6 MB
\&     DirectIPLookup   |    434  |  6.45M  | 0.77s | 33   MB
\&     RangeIPLookup    |    508  |  5.51M  | 0.88s |  0.51MB (+33MB)
\&       " (warm cache) |     61  | 45.9 M  |   "   |    "       "
.fi
.PP
The 
.M RadixIPLookup 7 ,
.M DirectIPLookup 7 ,
and 
.M RangeIPLookup 7
elements are well suited
for implementing large tables.  We also provide the 
.M LinearIPLookup 7 ,
.M StaticIPLookup 7 ,
and 
.M SortedIPLookup 7
elements; they are simple, but their O(N)
lookup speed is orders of magnitude slower.  
.M RadixIPLookup 7
or 
.M DirectIPLookup 7
should be preferred for almost all purposes.
.PP
.nf
\&           1500-entry fraction of the ICSI BGP dump
\& 
\&         Method     | cycles  | lookups | setup | lookup
\&                    | /lookup | /sec    | time  | tbl. size
\&     ---------------+---------+---------+-------+----------
\&     LinearIPLookup |  12000  |  233K   |  10s  |   29 KB
\&     StaticIPLookup |  12000  |  233K   |  10s  |   29 KB
\&     SortedIPLookup |  12500  |  224K   |  38s  |   29 KB
.fi
.PP
A Click script containing the 167000-route dump is available at
http://www.read.cs.ucla.edu/click/routetabletest-167k.click.gz
.PP


.SH "INTERFACE"
These four \fBIPRouteTable\fR virtual functions should generally be overridden by
particular routing table elements.
.PP


.IP "\f(CWint \fBadd_route\fR(const IPRoute& r, bool set, IPRoute* old_route, ErrorHandler *errh)\fR" 4
Add a route sending packets with destination addresses matching
\f(CWr.addr/r.mask\fR to gateway \f(CWr.gw\fR, via output port \f(CWr.port\fR.  If a route
for this exact prefix already exists, then the behavior depends on \f(CWset\fR.  If
\f(CWset\fR is true, then any existing route is silently overwritten (after
possibly being stored in \f(CW*old_route\fR); if \f(CWset\fR is false, the function
should return \f(CW-EEXIST\fR.  Report errors to \f(CWerrh\fR.  Should return 0 on
success and negative on failure.  The default implementation reports an error
"cannot add routes to this routing table".
.IP "" 4
.IP "\f(CWint \fBremove_route\fR(const IPRoute& r, IPRoute* old_route, ErrorHandler *errh)\fR" 4
Removes the route sending packets with destination addresses matching
\f(CWr.addr/r.mask\fR to gateway \f(CWr.gw\fR, via the element's output port \f(CWr.port\fR.
All four fields must match, unless \f(CWr.port\fR is less than 0, in which case
only \f(CWr.addr/r.mask\fR must match.  If no route for that prefix exists, the
function should return \f(CW-ENOENT\fR; otherwise, the old route should be stored
in \f(CW*old_route\fR (assuming it's not null).  Any errors are reported to
\f(CWerrh\fR.  Should return 0 on success and negative on failure.  The default
implementation reports an error "cannot delete routes from this routing
table".
.IP "" 4
.IP "\f(CWint \fBlookup_route\fR(IPAddress dst, IPAddress &gw_return) const\fR" 4
Looks up the route associated with address \f(CWdst\fR. Should set \f(CWgw_return\fR to
the resulting gateway and return the relevant output port (or negative if
there is no route). The default implementation returns -1.
.IP "" 4
.IP "\f(CWString \fBdump_routes\fR()\fR" 4
Returns a textual description of the current routing table. The default
implementation returns an empty string.
.IP "" 4
.PP
The following functions, overridden by \fBIPRouteTable\fR, are available for use by
subclasses.
.PP

.IP "\f(CWint \fBconfigure\fR(Vector<String> &conf, ErrorHandler *)\fR" 4
The default implementation of \fBconfigure\fR parses \f(CWconf\fR as a list of routes,
where each route is the space-separated list `\f(CWaddress/mask [gateway]
output\fR'. The routes are successively added to the element with \fBadd_route\fR.
.IP "" 4
.IP "\f(CWvoid \fBpush\fR(int port, Packet *p)\fR" 4
The default implementation of \fBpush\fR uses \fBlookup_route\fR to perform IP
routing lookup. Normally, subclasses implement their own \fBpush\fR methods,
avoiding virtual function call overhead.
.IP "" 4
.IP "\f(CWstatic int \fBadd_route_handler\fR(const String &, Element *, void *, ErrorHandler *)\fR" 4
This write handler callback parses its input as an add-route request
and calls \fBadd_route\fR with the results. Normally hooked up to the `\f(CWadd\fR'
handler.
.IP "" 4
.IP "\f(CWstatic int \fBremove_route_handler\fR(const String &, Element *, void *, ErrorHandler *)\fR" 4
This write handler callback parses its input as a remove-route request and
calls \fBremove_route\fR with the results. Normally hooked up to the `\f(CWremove\fR'
handler.
.IP "" 4
.IP "\f(CWstatic int \fBctrl_handler\fR(const String &, Element *, void *, ErrorHandler *)\fR" 4
This write handler callback function parses its input as a route control
request and calls \fBadd_route\fR or \fBremove_route\fR as directed. Normally hooked
up to the `\f(CWctrl\fR' handler.
.IP "" 4
.IP "\f(CWstatic String \fBtable_handler\fR(Element *, void *)\fR" 4
This read handler callback function returns the element's routing table via
the \fBdump_routes\fR function. Normally hooked up to the `\f(CWtable\fR' handler.
.IP "" 4
.PP

.SH "SEE ALSO"
.M RadixIPLookup 7 ,
.M DirectIPLookup 7 ,
.M RangeIPLookup 7 ,
.M StaticIPLookup 7 ,
.M LinearIPLookup 7 ,
.M SortedIPLookup 7 ,
.M LinuxIPLookup 7


.\" -*- mode: nroff -*-
.\" Generated by 'click-elem2man' from '../elements/userlevel/kerneltun.hh:10'
.de M
.IR "\\$1" "(\\$2)\\$3"
..
.de RM
.RI "\\$1" "\\$2" "(\\$3)\\$4"
..
.TH "KERNELTUN" 7click "12/Oct/2017" "Click"
.SH "NAME"
KernelTun \- Click element;
interface to /dev/tun or ethertap (user-level)
.SH "SYNOPSIS"
\fBKernelTun\fR(ADDR/MASK [, GATEWAY, \fIkeywords\fR HEADROOM, ETHER, MTU, IGNORE_QUEUE_OVERFLOWS])

\fBPorts\fR: at most 1 input, 1-2 outputs
.br
\fBDrivers\fR: userlevel
.br
.SH "DESCRIPTION"
Reads IP packets from and writes IP packets to a /dev/net/tun, /dev/tun*,
or /dev/tap* device.  This allows a user-level Click to hand packets to the
ordinary kernel IP processing code.  \fBKernelTun\fR will also install a routing
table entry so that the kernel can pass packets to the \fBKernelTun\fR device.
.PP
\fBKernelTun\fR produces and expects IP packets.  If, for some reason, the kernel
passes up a non-IP packet (or an invalid IP packet), \fBKernelTun\fR will emit
that packet on its second output, or drop it if there is no second output.
.PP
\fBKernelTun\fR allocates a /dev/net/tun, /dev/tun*, or /dev/tap* device (this
might fail) and runs 
.M ifconfig 8
to set the interface's local (i.e.,
kernel) address to ADDR and the netmask to MASK.  If a nonzero GATEWAY IP
address (which must be on the same network as the tun) is specified, then
\fBKernelTun\fR tries to set up a default route through that host.
.PP
When cleaning up, \fBKernelTun\fR attempts to bring down the device via
.M ifconfig 8 .
.PP
Keyword arguments are:
.PP


.IP "BURST" 8
Integer. The maximum number of packets to emit per scheduling. Default is 1.
.IP "" 8
.IP "HEADROOM" 8
Integer. The number of bytes left empty before output packet data to leave
room for additional encapsulation headers. Default is 28.
.IP "" 8
.IP "MTU" 8
Integer. The interface's MTU, not including any link headers. \fBKernelTun\fR will
refuse to send packets larger than the MTU. Default is 1500; not all operating
systems allow MTU to be set.
.IP "" 8
.IP "ETHER" 8
Ethernet address. Specifies the tunnel device's Ethernet address. Default is
00:01:02:03:04:05. On FreeBSD, any ETHER argument is silently ignored.
.IP "" 8
.IP "IGNORE_QUEUE_OVERFLOWS" 8
Boolean.  If true, don't print more than one error message when
there are queue overflows error when sending/receiving packets
to/from the tun device (e.g. there was an ENOBUFS error).  Default
is false.
.IP "" 8
.IP "DEVNAME" 8
String. If specified, try to alloc a tun device with name DEVNAME.
Otherwise, we'll just take the first virtual device we find. This option
only works with the Linux Universal TUN/TAP driver.
.IP "" 8
.PP

.SH "NOTES"
Make sure that your kernel has tun support enabled before running
\fBKernelTun\fR.  Initialization errors like "no such device" or "no such file or
directory" may indicate that your kernel isn't set up, or that some
required kernel module hasn't been loaded (on Linux, the relevant module is
"tun").
.PP
On Linux and most BSDs, packets sent to ADDR will be processed by the host
kernel stack; on Mac OS X there is no special handling for ADDR.
Packets sent to any (other) address in ADDR/MASK will be sent to \fBKernelTun\fR.
Say you run this configuration:
.PP
.nf
\&    tun :: KernelTun(1.0.0.1/8);
\&    tun -> IPClassifier(icmp type echo) -> ICMPPingResponder
\&        -> IPPrint -> tun;
.fi
.PP
On Linux and most BSDs, if you then "\f(CWping 1.0.0.1\fR", \fIyour own kernel\fR will respond:
Click will never see the packets, so it won't print anything.
But if you "\f(CWping 1.0.0.2\fR", the pings are sent to Click.  You should see printouts from Click,
and \f(CWping\fR should print Click's responses.
.PP
This element differs from 
.M KernelTap 7
in that it produces and expects IP
packets, not IP-in-Ethernet packets.
.PP


.SH "SEE ALSO"
.M FromDevice.u 7 ,
.M ToDevice.u 7 ,
.M KernelTap 7 ,
.M ifconfig 8


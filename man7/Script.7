.\" -*- mode: nroff -*-
.\" Generated by 'click-elem2man' from '../elements/standard/script.hh:9'
.de M
.IR "\\$1" "(\\$2)\\$3"
..
.de RM
.RI "\\$1" "\\$2" "(\\$3)\\$4"
..
.TH "SCRIPT" 7click "12/Oct/2017" "Click"
.SH "NAME"
Script \- Click element;
script a Click router configuration
.SH "SYNOPSIS"
\fBScript\fR(INSTRUCTIONS...)

\fBPorts\fR: normally none
.br
.SH "DESCRIPTION"
The \fBScript\fR element implements a simple scripting language useful for
controlling Click configurations.  Scripts can set variables, call handlers,
wait for prodding from other elements, and stop the router.
.PP

.SH "INSTRUCTIONS"
Each configuration argument is an \fIinstruction\fR (except for optional
keywords; see below).  \fBScript\fR generally processes these instructions
sequentially.
.PP

.SS "Handler Instructions"
In all cases, text arguments are subject to substitutions; see below.  Many
instructions come in two forms, as in \f(CWset\fR and \f(CWsetq\fR, \f(CWread\fR and
\f(CWreadq\fR, and \f(CWwrite\fR and \f(CWwriteq\fR.  The non-\f(CWq\fR forms perform
substitutions on the text, but do not remove any quotes from the result, while
the \f(CWq\fR forms perform substitutions and then remove a layer of quoting.  For
example, assuming the 'c.count' read handler returns 0:
.PP
.nf
\&   set x $(c.count)
\&   print $x             => 0
\&   set x "$(c.count)"
\&   print $x             => "0"
\&   setq x "$(c.count)"
\&   print $x             => 0
.fi
.PP



.IP "\&'\f(CWset\fR VAR TEXT', '\f(CWsetq\fR VAR TEXT'" 8
Sets the script variable $VAR to TEXT.
.IP "" 8
.IP "\&'\f(CWinit\fR VAR TEXT', '\f(CWinitq\fR VAR TEXT'" 8
Initializes the script variable $VAR to TEXT.  The assignment happens exactly
once, when the \fBScript\fR element is initialized.  Later the instruction has no
effect.
.IP "" 8
.IP "\&'\f(CWexport\fR VAR [TEXT]', '\f(CWexportq\fR VAR [TEXT]'" 8
Like \f(CWinit\fR, but also makes the value of script variable VAR available via a
read handler named VAR.
.IP "" 8
.IP "\&'\f(CWprint\fR [>FILE | >>FILE] [TEXT | HANDLER]'" 8
Prints text, or the result of calling a read handler, followed by a newline.
At user level, the text is written to the standard output, except that if the
argument begins with > or >>, then the text is written or appended to the
specified FILE.  In the kernel, the text is written to the system log.
.IP "" 8
If \f(CWprint\fR's argument starts with a letter, '@', or '_', then it is treated
as a read handler.  Otherwise, a layer of quotes is removed and the result is
printed.  For example, assuming the 'c.count' read handler returns "0":
.IP "" 8
.nf
\&   print c.count     => 0
\&   print "c.count"   => c.count
\&   print '"c.count"' => "c.count"
\&   set x c.count
\&   print $x          => c.count
\&   print $($x)       => 0
.fi
.IP "" 8


.IP "\&'\f(CWprintq\fR [>FILE | >>FILE] [TEXT | HANDLER]'" 8
Like \f(CWprint\fR, but unquotes HANDLER
.IP "" 8
.IP "\&'\f(CWprintn\fR [>FILE | >>FILE] [TEXT | HANDLER]'" 8
Like \f(CWprint\fR, but does not append a newline.
.IP "" 8
.IP "\&'\f(CWprintnq\fR [>FILE | >>FILE] [TEXT | HANDLER]'" 8
Like \f(CWprintn\fR, but unquotes HANDLER
.IP "" 8
.IP "\&'\f(CWread\fR HANDLER [ARGS]', '\f(CWreadq\fR HANDLER [ARGS]'" 8
Call a read handler and print the handler name and result to standard error.  (In the kernel, the result is printed to the system log.)  For example, the
configuration 'Idle -> c::Counter -> Idle; \fBScript\fR(read c.count)' would print
print this to standard error:
.IP "" 8
.nf
\&   c.count:
\&   0
.fi
.IP "" 8
Contrast the '\f(CWprint\fR' instruction.
.IP "" 8

.IP "\&'\f(CWwrite\fR HANDLER [ARGS]', '\f(CWwriteq\fR HANDLER [ARGS]'" 8
Call a write handler.  The handler's return status is available in following
instructions as the '$?' variable.
.IP "" 8
.PP

.SS "Blocking Instructions"


.IP "\&'\f(CWpause\fR [COUNT]'" 8
Block until the \fBScript\fR element's 'step' handler is called COUNT times.  COUNT
defaults to 1.
.IP "" 8
.IP "\&'\f(CWwait\fR TIME'" 8
Wait for TIME seconds, or until a step, whichever comes first; then go to the
next instruction.  TIME has microsecond precision.
.IP "" 8
.PP

.SS "Control Instructions"


.IP "\&'\f(CWlabel\fR LABEL'" 8
Defines a label named LABEL.
.IP "" 8
.IP "\&'\f(CWgoto\fR LABEL [CONDITION]'" 8
Transfers control to the named label.  \fBScript\fR elements detect loops; if an
element's script appears to be looping (it executes 1000 goto instructions
without blocking), the script is disabled.  If CONDITION is supplied, then the
branch executes only when CONDITION is true.
.IP "" 8
Also, '\f(CWgoto exit [CONDITION]\fR' and '\f(CWgoto end [CONDITION]\fR' end execution
of the script, like '\f(CWexit\fR' and '\f(CWend\fR' respectively.  '\f(CWgoto loop
[CONDITION]\fR' transfers control to the first instruction, like '\f(CWloop\fR'.
\&'\f(CWgoto error [CONDITION]\fR' ends execution of the script with an error, like
\&'\f(CWerror\fR'.  '\f(CWgoto stop [CONDITION]\fR' ends execution of the script and asks
the driver to stop, like '\f(CWstop\fR'.
.IP "" 8
.IP "\&'\f(CWloop\fR'" 8
Transfers control to the first instruction.
.IP "" 8
.IP "\&'\f(CWend\fR'" 8
End execution of this script.  In signal scripts, '\f(CWend\fR' causes the script
to be reinstalled as a signal handler.  In packet scripts, '\f(CWend\fR' emits
the packet on output 0.  An implicit '\f(CWend\fR' is executed if execution falls
off the end of a script.
.IP "" 8
.IP "\&'\f(CWexit\fR'" 8
End execution of this script.  In signal scripts, '\f(CWexit\fR' will \fInot\fR
reinstall the script as a signal handler.  In packet scripts, '\f(CWexit\fR' will
drop the packet.
.IP "" 8
.IP "\&'\f(CWstop\fR'" 8
End execution of this script as by '\f(CWend\fR', and additionally ask the driver
to stop.  (A TYPE DRIVER \fBScript\fR, or 
.M DriverManager 7
element, can intercept
this request.)
.IP "" 8
.IP "\&'\f(CWreturn\fR [VALUE]', '\f(CWreturnq\fR [VALUE]'" 8
End execution of this script.  In passive scripts, VALUE is returned as the
value of the \f(CWrun\fR handler.  In packet scripts, VALUE is the port on which
the packet should be emitted.
.IP "" 8
.IP "\&'\f(CWerror\fR [MSG]', '\f(CWerrorq\fR [MSG]'" 8
End execution of the script and indicate an error.  The optional error message
MSG is reported if given.
.IP "" 8
.PP

.SH "SCRIPT TYPES"
Scripts come in several types, including active scripts, which start running
as soon as the configuration is loaded; passive scripts, which run only when
prodded; signal scripts, which run in response to a signal; and driver
scripts, which are active scripts that also control when the driver stops.
.PP
The optional TYPE keyword argument selects a script type. The types
are:
.PP


.IP "\f(CWACTIVE\fR" 8
The script starts running as soon as the router is initialized. ACTIVE is
the default for \fBScript\fR elements without ports.
.IP "" 8
.IP "\f(CWPASSIVE\fR" 8
The script runs in response to a handler, namely the \f(CWrun\fR handler.
Passive scripts can help build complex handlers from existing simple ones; for
example, here's a passive script whose \f(CWs.run\fR read handler returns the sum
of two Counter handlers.
.IP "" 8
.nf
\&   ... c1 :: Counter ... c2 :: Counter ...
\&   s :: Script(TYPE PASSIVE,
\&          return $(add $(c1.count) $(c2.count)))
.fi
.IP "" 8
Within the script, the \f(CW$args\fR variable equals the \f(CWrun\fR handler's
arguments.  \f(CW$1\fR, \f(CW$2\fR, etc. equal the first, second, etc. space-separated
portions of \f(CW$args\fR, and \f(CW$#\fR equals the number of space-separated
arguments.
.IP "" 8

.IP "\f(CWPACKET\fR" 8
The script runs in response to a packet push or pull event. Within the
script, the \f(CW$input\fR variable equals the packet input port. The script's
return value is used as the output port number. PACKET is the default for
\fBScript\fR elements with ports.
.IP "" 8
.IP "\f(CWPROXY\fR" 8
The script runs in response to \fIany\fR handler (except \fBScript\fR's predefined
handlers).  Within the script, the \f(CW$0\fR variable equals the handler's name,
and the \f(CW$write\fR variable is "true" if the handler was called as a write
handler.  For example, consider:
.IP "" 8
.nf
\&   s :: Script(TYPE PROXY,
\&          goto nota $(ne $0 a),
\&          returnq "you called 'a'",
\&          label nota,
\&          goto notb $(ne $0 b),
\&          returnq "you called 'b'",
\&          label notb,
\&          error bad handler);
.fi
.IP "" 8
Calling the read handler "s.a" will return "you called 'a'", calling "s.b"
will return "you called 'b'", and anything else will produce a "bad handler"
error.
.IP "" 8

.IP "\f(CWDRIVER\fR" 8
The script manages the Click driver's stop events.  See 
.M DriverManager 7
for
more information.
.IP "" 8
.IP "\f(CWSIGNAL\fR SIGNO..." 8
User-level only: The script runs in response to the signal(s) specified
by the SIGNO argument(s).  Each SIGNO can be an integer or a signal name, such
as INT or HUP.  Soon after the driver receives a named signal, this script
will run.  The signal handler is automatically blocked until the script runs.
The signal script will be reinstalled atomically as long as the script
completes without blocking.  If it blocks, however, the signal script will not
be installed from the blocking point until the script completes.  If multiple
\fBScript\fR elements select the same signal, all the scripts will run.
.IP "" 8
.PP

.SH "SUBSTITUTIONS"
Text in most \fBScript\fR instructions undergoes variable substitution.  References
to script variables, such as '\f(CW$x\fR', are replaced by the variable text.
Additionally, the form '\f(CW$(HANDLER [ARG...])\fR' can be used to interpolate a
read handler's value.  Variable and handler references can be nested inside
a '\f(CW$(...)\fR' block.  For example, the following script will print 0, 1, 2, 3,
and 4 on separate lines, then exit.  Note the use of \fBScript\fR's arithmetic
handlers.
.PP
.nf
\&   s :: Script(set x 0,
\&               label begin_loop,
\&               print $x,
\&               set x $(s.add $x 1),
\&               goto begin_loop $(s.lt $x 5),
\&               stop);
.fi
.PP
This can be further shortened since local handler references do not require
the element name.  Thus, "$(s.add ...)" can be written "$(add ...)", as below.
.PP
.nf
\&   Script(set x 0,
\&          label begin_loop,
\&          print $x,
\&          set x $(add $x 1),
\&          goto begin_loop $(lt $x 5),
\&          stop);
.fi
.PP



.SH "ELEMENT HANDLERS"



.IP "\fBstep\fR (write-only)" 5
Advance the instruction pointer past the current blocking instruction (\f(CWpause\fR or \f(CWwait\fR).  A numeric argument will step past that many blocking instructions.
.IP "" 5
.IP "\fBgoto\fR (write-only)" 5
Move the instruction pointer to the specified label.
.IP "" 5
.IP "\fBrun\fR (read/write)" 5
Run the script.  If the script ends with a '\f(CWreturn\fR' instruction, then the
handler returns with that value.
.IP "" 5
.IP "\fBadd\fR (read with parameters)" 5
Useful for arithmetic.  Adds a space-separated list of integers; for example,
\&'\f(CWadd 10 5 2\fR' returns "\f(CW17\fR".  (At user level, the arithmetic and
comparison operators can parse floating-point numbers as well as integers.)
.IP "" 5
.IP "\fBsub\fR (read with parameters)" 5
Subtracts a space-separated list of
numbers; for example, '\f(CWsub 10 5 2\fR' returns
"\f(CW3\fR".
.IP "" 5
.IP "\fBmin, max\fR (read with parameters)" 5
Finds the minimum or maximum of a space-separated list of
numbers; for example, '\f(CWmax 5 10 2\fR' returns "\f(CW10\fR".
.IP "" 5
.IP "\fBmul, div, idiv\fR (read with parameters)" 5
Multiplies or divides a space-separated list of numbers and returns the
result.  At user level, the '\f(CWidiv\fR' handler truncates its result to an
integer and returns that, whereas the '\f(CWdiv\fR' handler returns a
floating-point number; in the kernel, '\f(CWidiv\fR' and '\f(CWdiv\fR' both perform
integer division.
.IP "" 5
.IP "\fBmod, rem\fR (read with parameters)" 5
Returns the remainder of two space-separated numbers; for example, '\f(CWmod 7 3\fR'
returns "\f(CW1\fR".  '\f(CWmod\fR' expects integer operands and returns the integer
modulus.  At user level, '\f(CWrem\fR' implements floating-point remainder; in the
kernel, it is the same as '\f(CWmod\fR'.
.IP "" 5
.IP "\fBneg\fR (read with parameters)" 5
Returns the negative of its numeric parameter.
.IP "" 5
.IP "\fBabs\fR (read with parameters)" 5
Returns the absolute value of its numeric parameter.
.IP "" 5
.IP "\fBeq, ne, lt, gt, le, ge\fR (read with parameters)" 5
Compares two parameters and returns the result.  For example, '\f(CWeq 10 0xA\fR'
returns "\f(CWtrue\fR", and '\f(CWle 9 8\fR' returns "\f(CWfalse\fR".  If either parameter
cannot be interpreted as a number, performs a string comparison in bytewise
lexicographic order.  For example, '\f(CWeq 10x 10x\fR' returns "\f(CWtrue\fR".
.IP "" 5
.IP "\fBnot\fR (read with parameters)" 5
Useful for true/false operations.  Parses its parameter as a Boolean and
returns its negation.
.IP "" 5
.IP "\fBand, or\fR (read with parameters)" 5
Useful for true/false operations.  Parses all parameters as Booleans and
returns their conjunction or disjunction, respectively.
.IP "" 5
.IP "\fBnand, nor\fR (read with parameters)" 5
Like "not (and ...)" and "not (or ...)", respectively.
.IP "" 5
.IP "\fBif\fR (read with parameters)" 5
Expects three space-separated parameters, the first a Boolean.  Returns the
second parameter if the Boolean is true, or the third parameter if the Boolean
is false.
.IP "" 5
.IP "\fBin\fR (read with parameters)" 5
Returns true if the first space-separated argument equals any of the other
arguments, using string comparison.  For example, '\f(CWin foo bar foo\fR'
returns "\f(CWtrue\fR".
.IP "" 5
.IP "\fBsprintf\fR (read with parameters)" 5
Parses its parameters as a space-separated list of arguments.  The first
argument is a format string; the remaining arguments are formatted
accordingly.  For example, '\f(CWsprintf "%05x" 127\fR' returns "\f(CW0007F\fR".
.IP "" 5
.IP "\fBrandom\fR (read with parameters)" 5
Given zero arguments, returns a random integer between 0 and RAND_MAX.  Given
one argument N, returns a random integer between 0 and N-1.  Given two
arguments N1 and N2, returns a random integer between N1 and N2.
.IP "" 5
.IP "\fBlength\fR (read with parameters)" 5
Returns the length of its parameter string as a decimal number.  For
example, '\f(CWread abcdef\fR' returns "\f(CW5\fR".
.IP "" 5
.IP "\fBunquote\fR (read with parameters)" 5
Returns its parameter string with one layer of quotes removed.
.IP "" 5
.IP "\fBreadable, writable\fR (read with parameters)" 5
Parses its parameters as a space-separated list of handler names.  Returns
true if all the named handlers exist and are readable (or writable).
.IP "" 5
.IP "\fBnow\fR (read-only)" 5
Returns the current timestamp.
.IP "" 5
.IP "\fBcat\fR (read with parameters)" 5
User-level only.  Argument is a filename; reads and returns the file's
contents.  This handler is not accessible via ControlSocket.
.IP "" 5
.IP "\fBcatq\fR (read with parameters)" 5
User-level only.  Like cat, but returns a quoted version of the file.
.IP "" 5
.IP "\fBkill\fR (read with parameters)" 5
User-level only.  Argument is a signal ID followed by one or more process
IDs.  Those processes are killed by that signal.  This handler is not
accessible via ControlSocket.  The "$$" variable may be useful when calling
\f(CWkill\fR; it expands to the driver's process ID.
.IP "" 5
.IP "\fBget\fR (read with parameters)" 5
The argument is a variable name.  Returns the value of that script variable.
.IP "" 5
.IP "\fBset\fR (write-only)" 5
The argument is a variable name, followed by a value.  Sets the named variable
to that value.
.IP "" 5
.IP "\fBshift\fR (write-only)" 5
The argument is a variable name, which defaults to \f(CWargs\fR.  Shifts the first
space-separated argument off the named variable and returns the result.
.IP "" 5
.PP

.SH "SEE ALSO"
.M DriverManager 7


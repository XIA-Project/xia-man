.\" -*- mode: nroff -*-
.\" Generated by 'click-elem2man' from '../elements/standard/bypass.hh:7'
.de M
.IR "\\$1" "(\\$2)\\$3"
..
.de RM
.RI "\\$1" "\\$2" "(\\$3)\\$4"
..
.TH "BYPASS" 7click "12/Oct/2017" "Click"
.SH "NAME"
Bypass \- Click element;
sends packet stream through optional bypass with zero overhead
.SH "SYNOPSIS"
\fBBypass\fR([ACTIVE])

\fBPorts\fR: 1-2 inputs, 1-2 outputs
.br
\fBProcessing\fR: agnostic
.br
.SH "DESCRIPTION"
\fBBypass\fR adds zero-overhead path switching to a configuration.
.PP
Normally, a \fBBypass\fR element emits received packets on its first output, like
.M Null 7 .
However, when ACTIVE is true, a push \fBBypass\fR element emits packets onto
output port 1. An active pull \fBBypass\fR forwards pull requests to input port 1.
.PP
Here's a typical use of a push \fBBypass\fR:
.PP
.nf
\&  ... source -> print_bypass :: Bypass -> sink ...;
\&  print_bypass [1] -> Print(Debug) -> sink;
.fi
.PP
To turn on the Print, write print_bypass.active to true.
.PP
You could implement this functionality multiple ways, for instance by using
.M Switch 7
or Print's "active" handler, but \fBBypass\fR is special because an inactive
\fBBypass\fR has \fIzero overhead\fR. \fBBypass\fR modifies its neighboring elements so that
packets skip over the \fBBypass\fR itself. In other words, the above configuration
behaves like one of the following two lines:
.PP
.nf
\&  ... source -> sink ...;
\&  ... source -> Print(Debug) -> sink ...;
.fi
.PP
\fBBypass\fR can have two inputs and outputs. The additional push input (pull
output) reconnects the bypass path to the normal path, and makes it easier to
use \fBBypass\fR in agnostic contexts. On a push \fBBypass\fR, packets received on input
port 1 are forwarded to output port 0; on a pull \fBBypass\fR, pull requests
received on output port 1 are forwarded to input port 0. The above
configuration could also be written this way:
.PP
.nf
\&  source :: TimedSource -> print_bypass :: Bypass -> sink ...;
\&  print_bypass [1] -> Print(Debug) -> [1] print_bypass;
.fi
.PP
And here is a pull version of \fBBypass\fR in a related configuration:
.PP
.nf
\&  source :: Queue -> print_bypass :: Bypass -> sink ...;
\&  print_bypass [1] -> Print(Debug) -> [1] print_bypass;
.fi
.PP
Note that the bypass path is exactly the same in both cases.
.PP
Keyword arguments are:
.PP



.IP "INLINE" 8
Boolean. If true, then \fBBypass\fR remains inline: it does not modify its
neighbors' ports, and it will introduce overhead. Default is false.
.IP "" 8
.PP

.SH "NOTES"
\fBBypass\fR modifies Click internals at run time, which can be dangerous. Elements
that test their neighbors' classes should not be used next to
\fBBypass\fR. (Elements should not test their neighbors' classes, however.) \fBBypass\fR
should not be used in a devirtualized configuration unless its INLINE argument
is set to true.
.PP

.SH "SEE ALSO"
.M Switch 7 ,
.M PullSwitch 7 ,
.M Null 7 ,
.M click-devirtualize 7


.\" -*- mode: nroff -*-
.\" Generated by 'click-elem2man' from '../elements/userlevel/mcastsocket.hh:11'
.de M
.IR "\\$1" "(\\$2)\\$3"
..
.de RM
.RI "\\$1" "\\$2" "(\\$3)\\$4"
..
.TH "MCASTSOCKET" 7click "12/Oct/2017" "Click"
.SH "NAME"
McastSocket \- Click element;
a multicast UDP socket transport (user-level)
.SH "SYNOPSIS"
\fBMcastSocket\fR(MCASTIP, MCASTPORT [, SOURCEIP] [, SOURCEPORT] [, \fIKEYWORDS\fR])

\fBPorts\fR: at most 1 input, at most 1 output
.br
.SH "DESCRIPTION"
Transports packets over multicast UDP. Packets do not flow through
\fBMcastSocket\fR elements (i.e., \fBMcastSocket\fR is an "x/y" element). Instead,
input packets are sent via multicast to any number of remote hosts or
processes, and packets from the remote hosts or processes are emitted
on the output.
.PP
If "SOURCEIP" (and optionally "SOURCEPORT") is specified, the address
is used as the source of outgoing packets, and the multicast traffic is
only sent and received on the interface designated by SOURCEIP.
.PP
If "SOURCEIP" is not specified, the system routing table determines the
source address and interface for sending and receiving the multicast
traffic.
.PP
Note that since the \fBMcastSocket\fR listens on the same multicast address
as it sends to, it will by default receive copies of its own packets.
If a source IP is specified, \fBMcastSocket\fR will automatically drop these
looping packets. If a source IP is not specified, disabling the LOOP
option can be an alternative, if no other subscribing processes run on
the same host as the Click process.
.PP
\fBMcastSocket\fR inputs are agnostic, i.e., they may be either "pull" or
"push". If pushed, packets will block on the underlying socket;
otherwise, the socket will pull packets as it can accept them. For
best performance, place a Notifier element (such as NotifierQueue)
upstream of a "pull" \fBMcastSocket\fR.
.PP
Keyword arguments are:
.PP


.IP "LOOP" 8
Boolean. Whether processes on the local machine (including this one!)
should receive copies of the outgoing traffic (IP_MULTICAST_LOOP).
The default is true.
.IP "" 8
.IP "SNAPLEN" 8
Unsigned integer. Maximum length of packets that can be
received. Default is 2048 bytes.
.IP "" 8
.IP "SNDBUF" 8
Unsigned integer. Sets the maximum size in bytes of the underlying
socket send buffer. The default value is set by the wmem_default
sysctl and the maximum allowed value is set by the wmem_max sysctl.
.IP "" 8
.IP "RCVBUF" 8
Unsigned integer. Sets the maximum size in bytes of the underlying
socket receive buffer. The default value is set by the rmem_default
sysctl and the maximum allowed value is set by the rmem_max sysctl.
.IP "" 8
.IP "TIMESTAMP" 8
Boolean. If set, sets the timestamp field on received packets to the
current time. Default is true.
.IP "" 8
.IP "HEADROOM" 8
Integer. Per-packet headroom. Defaults to 28.
.IP "" 8
.PP

.SH "EXAMPLES"
Start the following Click router:
.PP
.nf
\&  link :: McastSocket(239.0.0.0, 1234);
\& 
\&  arpR :: ARPResponder(10.0.0.1/32 02:02:02:02:02:02) -> link;
\&  arpQ :: ARPQuerier(10.0.0.1, 02:02:02:02:02:02) -> link;
\& 
\&  ip :: Strip(14)
\&  -> CheckIPHeader()
\&  -> IPClassifier(icmp and dst host 10.0.0.1)
\&  -> CheckICMPHeader()
\&  -> ICMPPingResponder()
\&  -> arpQ;
\& 
\&  // Note DROP_OWN to prevent multicast loop from messing things up.
\&  link
\&  -> HostEtherFilter(02:02:02:02:02:02, DROP_OWN true, DROP_OTHER true)
\&  -> Classifier(
\&      12/0806 20/0001, // ARP query
\&      12/0806 20/0002, // ARP reply
\&      12/0800, // IP
\&  ) => arpR, [1]arpQ, ip;
.fi
.PP
Then grab any Linux live CD image and start a QEMU virtual machine with
the following options:
.PP
.nf
\&  qemu -net nic -net socket,mcast=239.0.0.0:1234 -cdrom livecd.iso
.fi
.PP
After adding an IP address, you will be able to ping 10.0.0.1 from the
virtual machine. The use of multicast transparently bridges any number
of Click and QEMU processes on any number of hosts on a LAN.
.PP


.SH "SEE ALSO"
.M Socket 7


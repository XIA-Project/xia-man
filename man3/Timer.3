.TH "Timer" 3 "Thu Oct 12 2017" "Click" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Timer \- Triggers execution at a given time\&.  

.SH SYNOPSIS
.br
.PP
.SS "Public Types"

.in +1c
.ti -1c
.RI "enum { \fBbehind_sec\fP = 1 }"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBTimer\fP ()"
.br
.RI "\fIConstruct a \fBTimer\fP that does nothing when fired\&. \fP"
.ti -1c
.RI "\fBTimer\fP (const do_nothing_t &unused)"
.br
.RI "\fIConstruct a \fBTimer\fP that does nothing when fired\&. \fP"
.ti -1c
.RI "\fBTimer\fP (TimerCallback f, void *user_data)"
.br
.RI "\fIConstruct a \fBTimer\fP that calls \fIf\fP(this, \fIuser_data\fP) when fired\&. \fP"
.ti -1c
.RI "\fBTimer\fP (\fBElement\fP *\fBelement\fP)"
.br
.RI "\fIConstruct a \fBTimer\fP that calls \fIelement\fP ->\fBrun_timer\fP(this) when fired\&. \fP"
.ti -1c
.RI "\fBTimer\fP (\fBTask\fP *task)"
.br
.RI "\fIConstruct a \fBTimer\fP that schedules \fItask\fP when fired\&. \fP"
.ti -1c
.RI "\fBTimer\fP (const \fBTimer\fP &x)"
.br
.RI "\fIConstruct a \fBTimer\fP that acts like \fIx\fP when fired\&. \fP"
.ti -1c
.RI "\fB~Timer\fP ()"
.br
.RI "\fIDestroy a \fBTimer\fP, unscheduling it first if necessary\&. \fP"
.ti -1c
.RI "void \fBassign\fP ()"
.br
.RI "\fIChange the \fBTimer\fP to do nothing when fired\&. \fP"
.ti -1c
.RI "void \fBassign\fP (const do_nothing_t &unused)"
.br
.RI "\fIChange the \fBTimer\fP to do nothing when fired\&. \fP"
.ti -1c
.RI "void \fBassign\fP (TimerCallback f, void *user_data)"
.br
.RI "\fIChange the \fBTimer\fP to call \fIf\fP(this, \fIuser_data\fP) when fired\&. \fP"
.ti -1c
.RI "void \fBassign\fP (\fBElement\fP *\fBelement\fP)"
.br
.RI "\fIChange the \fBTimer\fP to call \fIelement\fP ->\fBrun_timer\fP(this) when fired\&. \fP"
.ti -1c
.RI "void \fBassign\fP (\fBTask\fP *task)"
.br
.RI "\fIChange the \fBTimer\fP to schedule \fItask\fP when fired\&. \fP"
.ti -1c
.RI "bool \fBinitialized\fP () const "
.br
.RI "\fIReturn true iff the \fBTimer\fP has been initialized\&. \fP"
.ti -1c
.RI "bool \fBscheduled\fP () const "
.br
.RI "\fIReturn true iff the \fBTimer\fP is currently scheduled\&. \fP"
.ti -1c
.RI "const \fBTimestamp\fP & \fBexpiry_steady\fP () const "
.br
.RI "\fIReturn the \fBTimer\fP's steady-clock expiration time\&. \fP"
.ti -1c
.RI "\fBTimestamp\fP \fBexpiry\fP () const "
.br
.RI "\fIReturn the \fBTimer\fP's system-clock expiration time\&. \fP"
.ti -1c
.RI "\fBRouter\fP * \fBrouter\fP () const "
.br
.RI "\fIReturn the \fBTimer\fP's associated \fBRouter\fP\&. \fP"
.ti -1c
.RI "\fBElement\fP * \fBelement\fP () const "
.br
.RI "\fIReturn the \fBTimer\fP's owning element\&. \fP"
.ti -1c
.RI "\fBRouterThread\fP * \fBthread\fP () const "
.br
.RI "\fIReturn the \fBTimer\fP's associated \fBRouterThread\fP\&. \fP"
.ti -1c
.RI "int \fBhome_thread_id\fP () const "
.br
.RI "\fIReturn the \fBTimer\fP's associated home thread ID\&. \fP"
.ti -1c
.RI "void \fBinitialize\fP (\fBElement\fP *owner, bool quiet=false)"
.br
.RI "\fIInitialize the timer\&. \fP"
.ti -1c
.RI "void \fBinitialize\fP (\fBRouter\fP *\fBrouter\fP)"
.br
.RI "\fIInitialize the timer\&. \fP"
.ti -1c
.RI "void \fBschedule_at_steady\fP (const \fBTimestamp\fP &when_steady)"
.br
.RI "\fISchedule the timer to fire at \fIwhen_steady\fP\&. \fP"
.ti -1c
.RI "void \fBreschedule_at_steady\fP (const \fBTimestamp\fP &when_steady)"
.br
.RI "\fISchedule the timer to fire at \fIwhen_steady\fP\&. \fP"
.ti -1c
.RI "void \fBschedule_at\fP (const \fBTimestamp\fP &when)"
.br
.RI "\fISchedule the timer to fire at \fIwhen\fP\&. \fP"
.ti -1c
.RI "void \fBreschedule_at\fP (const \fBTimestamp\fP &when)"
.br
.RI "\fISchedule the timer to fire at \fIwhen\fP\&. \fP"
.ti -1c
.RI "void \fBschedule_now\fP ()"
.br
.RI "\fIShedule the timer to fire immediately\&. \fP"
.ti -1c
.RI "void \fBschedule_after\fP (const \fBTimestamp\fP &delta)"
.br
.RI "\fISchedule the timer to fire \fIdelta\fP time in the future\&. \fP"
.ti -1c
.RI "void \fBschedule_after_sec\fP (uint32_t delta_sec)"
.br
.RI "\fISchedule the timer to fire after \fIdelta_sec\fP seconds\&. \fP"
.ti -1c
.RI "void \fBschedule_after_msec\fP (uint32_t delta_msec)"
.br
.RI "\fISchedule the timer to fire after \fIdelta_msec\fP milliseconds\&. \fP"
.ti -1c
.RI "void \fBreschedule_after\fP (const \fBTimestamp\fP &delta)"
.br
.RI "\fISchedule the timer to fire \fIdelta\fP time after its previous expiry\&. \fP"
.ti -1c
.RI "void \fBreschedule_after_sec\fP (uint32_t delta_sec)"
.br
.RI "\fISchedule the timer to fire \fIdelta_sec\fP seconds after its previous expiry\&. \fP"
.ti -1c
.RI "void \fBreschedule_after_msec\fP (uint32_t delta_msec)"
.br
.RI "\fISchedule the timer to fire \fIdelta_msec\fP milliseconds after its previous expiry\&. \fP"
.ti -1c
.RI "void \fBunschedule\fP ()"
.br
.RI "\fIUnschedule the timer\&. \fP"
.ti -1c
.RI "void \fBclear\fP ()"
.br
.RI "\fIUnschedule the timer and reset its expiration time\&. \fP"
.ti -1c
.RI "void \fBschedule_after_s\fP (uint32_t delta_sec)"
.br
.RI "\fISchedule the timer to fire after \fIdelta_sec\fP seconds (deprecated)\&. \fP"
.ti -1c
.RI "void \fBschedule_after_ms\fP (uint32_t delta_sec)"
.br
.RI "\fISchedule the timer to fire after \fIdelta_msec\fP milliseconds (deprecated)\&. \fP"
.ti -1c
.RI "void \fBreschedule_after_s\fP (uint32_t delta_sec)"
.br
.RI "\fISchedule the timer to fire \fIdelta_sec\fP seconds after its previous expiry time (deprecated)\&. \fP"
.ti -1c
.RI "void \fBreschedule_after_ms\fP (uint32_t delta_sec)"
.br
.RI "\fISchedule the timer to fire \fIdelta_msec\fP milliseconds after its previous expiry time (deprecated)\&. \fP"
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static \fBTimestamp\fP \fBadjustment\fP ()"
.br
.RI "\fIReturn an adjustment interval useful for precise timers\&. \fP"
.in -1c
.SH "Detailed Description"
.PP 
Triggers execution at a given time\&. 

Click \fBTimer\fP objects trigger the execution of code after a specific time\&. Click's version of 'ping' (the ICMPPingSource element) uses \fBTimer\fP objects to create ping packets at specific times\&. Many other elements, such as IPRewriter, garbage-collect their internal state based on timers\&. An element that needs to run occasional timed tasks includes and initializes a \fBTimer\fP instance variable\&. When scheduled, most timers call their associated element's \fBrun_timer()\fP method\&.
.PP
Each scheduled \fBTimer\fP has a single expiration \fBTimestamp\fP\&. To implement a periodic timer, reschedule the timer as appropriate\&.
.PP
.SS "Examples"
.PP
This example element code, based on TimedSource, will print a message every 5 seconds:
.PP
.PP
.nf
#include <click/element\&.hh>
#include <click/timer\&.hh>

class PeriodicPrinter : public Element { public:
    PeriodicPrinter();
    const char *class_name() const { return "PeriodicPrinter"; }
    int initialize(ErrorHandler *errh);
    void run_timer(Timer *timer);
  private:
    Timer _timer;
};

PeriodicPrinter::PeriodicPrinter()
    : _timer(this)    // Sets _timer to call this->run_timer(&_timer)
{                     // when it fires\&.
}

int PeriodicPrinter::initialize(ErrorHandler *) {
    _timer\&.initialize(this);   // Initialize timer object (mandatory)\&.
    _timer\&.schedule_now();     // Set the timer to fire as soon as the
                               // router runs\&.
    return 0;
}

void PeriodicPrinter::run_timer(Timer *timer) {
    // This function is called when the timer fires\&.
    assert(timer == &_timer);
    Timestamp now = Timestamp::now_steady();
    click_chatter("%s: %p{timestamp}: timer fired with expiry %p{timestamp}!\n",
                  declaration()\&.c_str(), &now, &_timer\&.expiry_steady());
           // _timer\&.expiry_steady() is the steady-clock Timestamp
           // at which the timer was set to fire\&.
    _timer\&.reschedule_after_sec(5);  // Fire again 5 seconds later\&.
}
.fi
.PP
.PP
Running this element might produce output like this:
.PP
.PP
.nf

pp: 1204658365\&.127870: timer fired with expiry 1204658365\&.127847!
pp: 1204658370\&.127911: timer fired with expiry 1204658370\&.127847!
pp: 1204658375\&.127877: timer fired with expiry 1204658375\&.127847!
pp: 1204658380\&.127874: timer fired with expiry 1204658380\&.127847!
pp: 1204658385\&.127876: timer fired with expiry 1204658385\&.127847!
pp: 1204658390\&.127926: timer fired with expiry 1204658390\&.127847!
pp: 1204658395\&.128044: timer fired with expiry 1204658395\&.127847!
.fi
.PP
.PP
The expiry time measures when the timer was supposed to fire, while \fBTimestamp::now_steady()\fP reports the current steady-clock time\&. Note that the timer's expiry time goes up by exactly 5 seconds each time, and that steady-clock time is always later than the expiry time\&.
.PP
Click aims to fire the timer as soon as possible after the expiry time, but cannot hit the expiry time exactly\&. The \fBreschedule_after_sec()\fP function and its variants (\fBreschedule_after()\fP, \fBreschedule_after_msec()\fP) schedule the next firing based on the previous expiry time\&. This makes the timer's action more robust to runtime fluctuations\&. Compare:
.PP
.PP
.nf
void PeriodicPrinter::run_timer(Timer *timer) {
    Timestamp now = Timestamp::now_steady();
    click_chatter("%s: %p{timestamp}: timer fired with expiry %p{timestamp}!\n",
                  name()\&.c_str(), &now, &_timer\&.expiry_steady());
    _timer\&.schedule_after_sec(5);  // Fire again 5 seconds later\&.
        // This is the same as:
        // _timer\&.schedule_at_steady(Timestamp::now_steady() + Timestamp::make_sec(5));
}
.fi
.PP
.PP
The \fBschedule_after_sec()\fP function sets the timer to fire an interval after the \fIcurrent steady-clock time\fP, not the previous expiry\&. As a result, the timer drifts:
.PP
.PP
.nf

pp: 1204658494\&.374277: timer fired with expiry 1204658494\&.374256!
pp: 1204658499\&.374575: timer fired with expiry 1204658499\&.374478!
pp: 1204658504\&.375261: timer fired with expiry 1204658504\&.375218!
pp: 1204658509\&.375428: timer fired with expiry 1204658509\&.375381!
\&.\&.\&.
pp: 1204658884\&.998112: timer fired with expiry 1204658884\&.998074!
pp: 1204658890\&.001909: timer fired with expiry 1204658889\&.998209!
pp: 1204658895\&.002399: timer fired with expiry 1204658895\&.002175!
pp: 1204658900\&.003626: timer fired with expiry 1204658900\&.003589!
.fi
.PP
.PP
Timers that are set to fire more than 1 second in the past are silently updated to the current steady-clock time\&. Thus, the \fBreschedule_after()\fP methods will never fall more than a second or two behind steady-clock time\&.
.PP
.SS "Notes"
.PP
Elements desiring extremely frequent access to the CPU, up to tens of thousands of times a second, should use a \fBTask\fP object rather than a \fBTimer\fP\&. However, Tasks essentially busy-wait, taking up all available CPU\&. There is a tradeoff, and some elements combine a \fBTask\fP and a \fBTimer\fP to get the benefits of both; for example, LinkUnqueue uses a \fBTask\fP at high rates and a \fBTimer\fP at low rates\&. The \fBTimer::adjustment()\fP value is useful in this context\&.
.PP
Particularly at user level, there can be a significant delay between a \fBTimer\fP's nominal expiration time and the actual time it runs\&. Elements that desire extremely precise timings should combine a \fBTimer\fP with a \fBTask\fP\&. The \fBTimer\fP is set to go off a bit before the true expiration time (see \fBTimer::adjustment()\fP), after which the \fBTask\fP polls the CPU until the actual expiration time arrives\&.
.PP
Since Click is cooperatively scheduled, any timer callback should run for just a short period of time\&. Very long callbacks can inappropriately delay other timers and periodic events\&.
.PP
The Click core stores timers in a heap, so most timer operations (including scheduling and unscheduling) take \fIO\fP(log \fIn\fP) time and Click can handle very large numbers of timers\&.
.PP
Timers generally run in increasing order by expiration time\&. That is, if timer \fIa's\fP \fBexpiry()\fP is less than timer \fIb's\fP \fBexpiry()\fP, then \fIa\fP will generally fire before \fIb\fP\&. However, Click must sometimes run timers out of order to ensure fairness\&. The only strict guarantee is that a \fBTimer\fP will run after its nominal expiration time\&. 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "Timer::Timer ()"

.PP
Construct a \fBTimer\fP that does nothing when fired\&. This constructor is most useful for a \fBTimer\fP that will be assigned a true callback later, using one of the \fBTimer::assign()\fP methods\&. \fBTimer::initialize()\fP will report a warning if called on a \fBTimer\fP created by this constructor\&. 
.SS "Timer::Timer (const do_nothing_t & unused)"

.PP
Construct a \fBTimer\fP that does nothing when fired\&. Unlike with the default \fBTimer()\fP constructor, \fBTimer::initialize()\fP will not report a warning if called on a \fBTimer\fP created by this constructor\&. 
.SS "Timer::Timer (TimerCallback f, void * user_data)"

.PP
Construct a \fBTimer\fP that calls \fIf\fP(this, \fIuser_data\fP) when fired\&. 
.PP
\fBParameters:\fP
.RS 4
\fIf\fP callback function 
.br
\fIuser_data\fP argument for callback function 
.RE
.PP

.SS "Timer::Timer (\fBElement\fP * element)"

.PP
Construct a \fBTimer\fP that calls \fIelement\fP ->\fBrun_timer\fP(this) when fired\&. 
.PP
\fBParameters:\fP
.RS 4
\fIelement\fP the element 
.RE
.PP

.SS "Timer::Timer (\fBTask\fP * task)"

.PP
Construct a \fBTimer\fP that schedules \fItask\fP when fired\&. 
.PP
\fBParameters:\fP
.RS 4
\fItask\fP the task 
.RE
.PP

.SS "Timer::Timer (const \fBTimer\fP & x)"

.PP
Construct a \fBTimer\fP that acts like \fIx\fP when fired\&. The newly-constructed \fBTimer\fP is not initialized\&. 
.SS "Timer::~Timer ()\fC [inline]\fP"

.PP
Destroy a \fBTimer\fP, unscheduling it first if necessary\&. 
.SH "Member Function Documentation"
.PP 
.SS "void Timer::assign ()\fC [inline]\fP"

.PP
Change the \fBTimer\fP to do nothing when fired\&. 
.SS "void Timer::assign (const do_nothing_t & unused)\fC [inline]\fP"

.PP
Change the \fBTimer\fP to do nothing when fired\&. 
.SS "void Timer::assign (TimerCallback f, void * user_data)\fC [inline]\fP"

.PP
Change the \fBTimer\fP to call \fIf\fP(this, \fIuser_data\fP) when fired\&. 
.PP
\fBParameters:\fP
.RS 4
\fIf\fP callback function 
.br
\fIuser_data\fP argument for callback function 
.RE
.PP

.SS "void Timer::assign (\fBElement\fP * element)\fC [inline]\fP"

.PP
Change the \fBTimer\fP to call \fIelement\fP ->\fBrun_timer\fP(this) when fired\&. 
.PP
\fBParameters:\fP
.RS 4
\fIelement\fP the element 
.RE
.PP

.SS "void Timer::assign (\fBTask\fP * task)\fC [inline]\fP"

.PP
Change the \fBTimer\fP to schedule \fItask\fP when fired\&. 
.PP
\fBParameters:\fP
.RS 4
\fItask\fP the task 
.RE
.PP

.SS "bool Timer::initialized () const\fC [inline]\fP"

.PP
Return true iff the \fBTimer\fP has been initialized\&. 
.SS "bool Timer::scheduled () const\fC [inline]\fP"

.PP
Return true iff the \fBTimer\fP is currently scheduled\&. 
.SS "const \fBTimestamp\fP& Timer::expiry_steady () const\fC [inline]\fP"

.PP
Return the \fBTimer\fP's steady-clock expiration time\&. This is the absolute time, according to the steady clock, at which the timer is next scheduled to fire\&. If the timer is not currently scheduled, then \fBexpiry_steady()\fP returns the last assigned expiration time\&.
.PP
\fBSee also:\fP
.RS 4
\fBexpiry()\fP 
.RE
.PP

.SS "\fBTimestamp\fP Timer::expiry () const\fC [inline]\fP"

.PP
Return the \fBTimer\fP's system-clock expiration time\&. \fBTimer\fP expirations are measured using the system's steady clock, which increases monotonically\&. (See \fBTimestamp::now_steady()\fP\&.) The \fBexpiry()\fP function, however, returns the timer's expiration time according to the system clock\&. This is a calculated value: if the system clock changes -- because the user changes the current system time, for example -- then the timer's \fBexpiry()\fP will also change\&. (The timer's \fBexpiry_steady()\fP value will not change, however\&.)
.PP
\fBSee also:\fP
.RS 4
\fBexpiry_steady()\fP 
.RE
.PP

.SS "\fBRouter\fP* Timer::router () const\fC [inline]\fP"

.PP
Return the \fBTimer\fP's associated \fBRouter\fP\&. 
.SS "\fBElement\fP* Timer::element () const\fC [inline]\fP"

.PP
Return the \fBTimer\fP's owning element\&. 
.SS "\fBRouterThread\fP* Timer::thread () const\fC [inline]\fP"

.PP
Return the \fBTimer\fP's associated \fBRouterThread\fP\&. 
.SS "int Timer::home_thread_id () const"

.PP
Return the \fBTimer\fP's associated home thread ID\&. 
.SS "void Timer::initialize (\fBElement\fP * owner, bool quiet = \fCfalse\fP)"

.PP
Initialize the timer\&. 
.PP
\fBParameters:\fP
.RS 4
\fIowner\fP the owner element 
.br
\fIquiet\fP do not produce default-constructor warning if true
.RE
.PP
Before a timer can be used, it must be attached to a containing router\&. When that router is destroyed, the timer is automatically unscheduled\&. It is safe to initialize the timer multiple times on the same router\&.
.PP
If Click is compiled with statistics support, time spent in this \fBTimer\fP will be charged to the \fIowner\fP element\&.
.PP
Initializing a \fBTimer\fP constructed by the default constructor, \fBTimer()\fP, will produce a warning\&. 
.SS "void Timer::initialize (\fBRouter\fP * router)"

.PP
Initialize the timer\&. 
.PP
\fBParameters:\fP
.RS 4
\fIrouter\fP the owner router
.RE
.PP
This function is shorthand for \fBTimer::initialize\fP(\fIrouter\fP ->\fBroot_element\fP())\&. However, it is better to explicitly associate timers with real elements\&. 
.SS "void Timer::schedule_at_steady (const \fBTimestamp\fP & when_steady)"

.PP
Schedule the timer to fire at \fIwhen_steady\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIwhen_steady\fP expiration time according to the steady clock
.RE
.PP
If \fIwhen_steady\fP is more than 2 seconds behind the current time, then the expiration time is silently updated to the current time\&.
.PP
\fBSee also:\fP
.RS 4
\fBschedule_at()\fP 
.RE
.PP

.SS "void Timer::reschedule_at_steady (const \fBTimestamp\fP & when_steady)"

.PP
Schedule the timer to fire at \fIwhen_steady\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIwhen_steady\fP expiration time according to the steady clock
.RE
.PP
This is a synonym for \fBschedule_at_steady()\fP\&. 
.SS "void Timer::schedule_at (const \fBTimestamp\fP & when)\fC [inline]\fP"

.PP
Schedule the timer to fire at \fIwhen\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIwhen\fP expiration time according to the system clock
.RE
.PP
If \fIwhen\fP is more than 2 seconds behind system time, then the expiration time is silently updated to the current system time\&.
.PP
\fBNote:\fP
.RS 4
The \fBschedule_at_steady()\fP function should generally be preferred to \fBschedule_at()\fP\&. \fBschedule_at()\fP is implemented in terms of \fBschedule_at_steady()\fP\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBschedule_at_steady()\fP 
.RE
.PP

.SS "void Timer::reschedule_at (const \fBTimestamp\fP & when)\fC [inline]\fP"

.PP
Schedule the timer to fire at \fIwhen\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIwhen\fP expiration time
.RE
.PP
This is a synonym for \fBschedule_at()\fP\&. 
.SS "void Timer::schedule_now ()\fC [inline]\fP"

.PP
Shedule the timer to fire immediately\&. Equivalent to schedule_at(Timestamp::recent())\&. 
.SS "void Timer::schedule_after (const \fBTimestamp\fP & delta)"

.PP
Schedule the timer to fire \fIdelta\fP time in the future\&. 
.PP
\fBParameters:\fP
.RS 4
\fIdelta\fP interval until expiration time
.RE
.PP
The schedule_after methods schedule the timer relative to the current time\&. When called from a timer's callback function, this will usually be slightly after the timer's nominal expiration time\&. To schedule a timer at a strict interval, compensating for small amounts of drift, use the reschedule_after methods\&. 
.SS "void Timer::schedule_after_sec (uint32_t delta_sec)\fC [inline]\fP"

.PP
Schedule the timer to fire after \fIdelta_sec\fP seconds\&. 
.PP
\fBParameters:\fP
.RS 4
\fIdelta_sec\fP interval until expiration time, in seconds
.RE
.PP
\fBSee also:\fP
.RS 4
\fBschedule_after\fP, \fBreschedule_after_sec\fP 
.RE
.PP

.SS "void Timer::schedule_after_msec (uint32_t delta_msec)\fC [inline]\fP"

.PP
Schedule the timer to fire after \fIdelta_msec\fP milliseconds\&. 
.PP
\fBParameters:\fP
.RS 4
\fIdelta_msec\fP interval until expiration time, in milliseconds
.RE
.PP
\fBSee also:\fP
.RS 4
\fBschedule_after\fP, \fBreschedule_after_msec\fP 
.RE
.PP

.SS "void Timer::reschedule_after (const \fBTimestamp\fP & delta)\fC [inline]\fP"

.PP
Schedule the timer to fire \fIdelta\fP time after its previous expiry\&. 
.PP
\fBParameters:\fP
.RS 4
\fIdelta\fP interval until expiration time
.RE
.PP
If the expiration time is too far in the past, then the new expiration time will be silently updated to the current system time\&.
.PP
\fBSee also:\fP
.RS 4
\fBschedule_after\fP 
.RE
.PP

.SS "void Timer::reschedule_after_sec (uint32_t delta_sec)\fC [inline]\fP"

.PP
Schedule the timer to fire \fIdelta_sec\fP seconds after its previous expiry\&. 
.PP
\fBParameters:\fP
.RS 4
\fIdelta_sec\fP interval until expiration time, in seconds
.RE
.PP
\fBSee also:\fP
.RS 4
\fBschedule_after_sec\fP, \fBreschedule_after\fP 
.RE
.PP

.SS "void Timer::reschedule_after_msec (uint32_t delta_msec)\fC [inline]\fP"

.PP
Schedule the timer to fire \fIdelta_msec\fP milliseconds after its previous expiry\&. 
.PP
\fBParameters:\fP
.RS 4
\fIdelta_msec\fP interval until expiration time, in milliseconds
.RE
.PP
\fBSee also:\fP
.RS 4
\fBschedule_after_msec\fP, \fBreschedule_after\fP 
.RE
.PP

.SS "void Timer::unschedule ()"

.PP
Unschedule the timer\&. The timer's expiration time is not modified\&. 
.SS "void Timer::clear ()\fC [inline]\fP"

.PP
Unschedule the timer and reset its expiration time\&. 
.SS "static \fBTimestamp\fP Timer::adjustment ()\fC [inline]\fP, \fC [static]\fP"

.PP
Return an adjustment interval useful for precise timers\&. Due to scheduling granularity, other tasks running on the same machine, and similar effects, a \fBTimer\fP object can trigger some time after its nominal \fBexpiry()\fP\&. Functions that require precise timers should combine a \fBTimer\fP and a \fBTask\fP object\&. The \fBTimer\fP's job is to schedule the \fBTask\fP; the \fBTimer\fP's expiry is set to go off a short interval before the true expiry, and the \fBTask\fP is used to busy-wait the difference\&. \fBTimer::adjustment()\fP is an appropriate value for this time difference\&. 
.SS "void Timer::schedule_after_s (uint32_t delta_sec)\fC [inline]\fP"

.PP
Schedule the timer to fire after \fIdelta_sec\fP seconds (deprecated)\&. 
.PP
\fBDeprecated\fP
.RS 4
Use \fBschedule_after_sec()\fP instead\&. 
.RE
.PP

.SS "void Timer::schedule_after_ms (uint32_t delta_sec)\fC [inline]\fP"

.PP
Schedule the timer to fire after \fIdelta_msec\fP milliseconds (deprecated)\&. 
.PP
\fBDeprecated\fP
.RS 4
Use \fBschedule_after_msec()\fP instead\&. 
.RE
.PP

.SS "void Timer::reschedule_after_s (uint32_t delta_sec)\fC [inline]\fP"

.PP
Schedule the timer to fire \fIdelta_sec\fP seconds after its previous expiry time (deprecated)\&. 
.PP
\fBDeprecated\fP
.RS 4
Use \fBreschedule_after_sec()\fP instead\&. 
.RE
.PP

.SS "void Timer::reschedule_after_ms (uint32_t delta_sec)\fC [inline]\fP"

.PP
Schedule the timer to fire \fIdelta_msec\fP milliseconds after its previous expiry time (deprecated)\&. 
.PP
\fBDeprecated\fP
.RS 4
Use \fBreschedule_after_msec()\fP instead\&. 
.RE
.PP


.SH "Author"
.PP 
Generated automatically by Doxygen for Click from the source code\&.

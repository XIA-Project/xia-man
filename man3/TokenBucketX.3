.TH "TokenBucketX< P >" 3 "Thu Oct 12 2017" "Click" \" -*- nroff -*-
.ad l
.nh
.SH NAME
TokenBucketX< P > \- Token bucket rate limiter\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <click/tokenbucket\&.hh>\fP
.SS "Public Types"

.in +1c
.ti -1c
.RI "enum { \fBmax_tokens\fP = rate_type::max_tokens }"
.br
.ti -1c
.RI "typedef P \fBparameter_type\fP"
.br
.RI "\fIThe template parameter type\&. \fP"
.ti -1c
.RI "typedef \fBTokenRateX\fP< P > \fBrate_type\fP"
.br
.RI "\fIThe token rate type\&. \fP"
.ti -1c
.RI "typedef \fBTokenCounterX\fP< \fBrate_type\fP > \fBcounter_type\fP"
.br
.RI "\fIThe token counter type\&. \fP"
.ti -1c
.RI "typedef \fBrate_type::token_type\fP \fBtoken_type\fP"
.br
.RI "\fIUnsigned type of token counts\&. \fP"
.ti -1c
.RI "typedef \fBrate_type::time_point_type\fP \fBtime_point_type\fP"
.br
.RI "\fIType of time ticks\&. \fP"
.ti -1c
.RI "typedef \fBrate_type::ticks_type\fP \fBticks_type\fP"
.br
.RI "\fIUnsigned type of differences between time ticks\&. \fP"
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBTokenBucketX\fP ()"
.br
.RI "\fIConstruct an idle token bucket\&. \fP"
.ti -1c
.RI "\fBTokenBucketX\fP (bool \fBunlimited\fP)"
.br
.RI "\fIConstruct an idle or unlimited token bucket\&. \fP"
.ti -1c
.RI "\fBTokenBucketX\fP (\fBtoken_type\fP \fBrate\fP, \fBtoken_type\fP \fBcapacity\fP)"
.br
.RI "\fIConstruct a token bucket representing \fIrate\fP\&. \fP"
.ti -1c
.RI "void \fBassign\fP (bool \fBunlimited\fP=false)"
.br
.RI "\fISet the token bucket rate to idle or unlimited\&. \fP"
.ti -1c
.RI "void \fBassign\fP (\fBtoken_type\fP \fBrate\fP, \fBtoken_type\fP \fBcapacity\fP)"
.br
.RI "\fISet the token bucket rate and capacity\&. \fP"
.ti -1c
.RI "void \fBassign_adjust\fP (\fBtoken_type\fP \fBrate\fP, \fBtoken_type\fP \fBcapacity\fP)"
.br
.RI "\fISet the token bucket rate and capacity, preserving the token count\&. \fP"
.ti -1c
.RI "bool \fBunlimited\fP () const "
.br
.RI "\fIReturn true iff the token rate is unlimited\&. \fP"
.ti -1c
.RI "bool \fBidle\fP () const "
.br
.RI "\fIReturn true iff the token rate is idle\&. \fP"
.ti -1c
.RI "\fBtoken_type\fP \fBrate\fP () const "
.br
.RI "\fIReturn the rate in tokens per period\&. \fP"
.ti -1c
.RI "\fBtoken_type\fP \fBcapacity\fP () const "
.br
.RI "\fIReturn the capacity in tokens\&. \fP"
.ti -1c
.RI "\fBtoken_type\fP \fBsize\fP () const "
.br
.RI "\fIReturn the number of tokens in the bucket\&. \fP"
.ti -1c
.RI "\fBtoken_type\fP \fBfraction\fP () const "
.br
.RI "\fIReturn the bucket's fullness fraction\&. \fP"
.ti -1c
.RI "bool \fBempty\fP () const "
.br
.RI "\fITest if the token bucket is completely empty\&. \fP"
.ti -1c
.RI "bool \fBfull\fP () const "
.br
.RI "\fITest if the token bucket is at full capacity\&. \fP"
.ti -1c
.RI "bool \fBcontains\fP (\fBtoken_type\fP t) const "
.br
.RI "\fITest if the token bucket has at least \fIt\fP tokens\&. \fP"
.ti -1c
.RI "bool \fBcontains_fraction\fP (\fBtoken_type\fP f) const "
.br
.RI "\fITest if the token bucket is above a fraction of its capacity\&. \fP"
.ti -1c
.RI "void \fBclear\fP ()"
.br
.RI "\fIClear the token bucket\&. \fP"
.ti -1c
.RI "void \fBset_full\fP ()"
.br
.RI "\fIFill the token bucket to capacity\&. \fP"
.ti -1c
.RI "void \fBset\fP (\fBtoken_type\fP t)"
.br
.RI "\fISet the token bucket to contain \fIt\fP tokens\&. \fP"
.ti -1c
.RI "void \fBset_fraction\fP (\fBtoken_type\fP f)"
.br
.RI "\fISet the token bucket to a fraction of its capacity\&. \fP"
.ti -1c
.RI "void \fBrefill\fP ()"
.br
.RI "\fIRefill the token bucket to time P::now()\&. \fP"
.ti -1c
.RI "void \fBrefill\fP (\fBtime_point_type\fP time)"
.br
.RI "\fIRefill the token bucket for \fItime\fP\&. \fP"
.ti -1c
.RI "template<typename U > void \fBrefill\fP (U time)"
.br
.RI "\fIRefill the token bucket for time P::time_point(\fItime\fP)\&. \fP"
.ti -1c
.RI "void \fBset_time_point\fP (\fBtime_point_type\fP time)"
.br
.RI "\fISet the token bucket's internal time point to \fItime\fP\&. \fP"
.ti -1c
.RI "void \fBremove\fP (\fBtoken_type\fP t)"
.br
.RI "\fIRemove \fIt\fP tokens from the bucket\&. \fP"
.ti -1c
.RI "bool \fBremove_if\fP (\fBtoken_type\fP t)"
.br
.RI "\fIRemove \fIt\fP tokens from the bucket if it contains \fIt\fP tokens\&. \fP"
.ti -1c
.RI "void \fBremove_fraction\fP (\fBtoken_type\fP f)"
.br
.RI "\fIRemove a fullness fraction from the bucket\&. \fP"
.ti -1c
.RI "bool \fBremove_fraction_if\fP (\fBtoken_type\fP f)"
.br
.RI "\fIRemove a fullness fraction from the bucket if it is full enough\&. \fP"
.ti -1c
.RI "\fBticks_type\fP \fBtime_until_contains\fP (\fBtoken_type\fP t) const "
.br
.RI "\fIReturn the number of ticks until contains(\fIt\fP)\&. \fP"
.ti -1c
.RI "\fBticks_type\fP \fBtime_until_contains_fraction\fP (\fBticks_type\fP f) const "
.br
.RI "\fIReturn the number of ticks until contains_fraction(\fIf\fP)\&. \fP"
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename P>
.br
class TokenBucketX< P >"
Token bucket rate limiter\&. 

The \fBTokenBucketX\fP class implements a token bucket rate limiter\&. It is implemented as a pair of \fBTokenRateX\fP and \fBTokenCounterX\fP\&.
.PP
Most users will be satisfied with the \fBTokenBucket\fP type, which is equal to \fBTokenBucketX\fP<TokenBucketJiffyParameters<unsigned> >\&.
.PP
\fBSee also:\fP
.RS 4
\fBGapRate\fP 
.RE
.PP

.SH "Member Typedef Documentation"
.PP 
.SS "template<typename P> typedef P \fBTokenBucketX\fP< P >::\fBparameter_type\fP"

.PP
The template parameter type\&. 
.SS "template<typename P> typedef \fBTokenRateX\fP<P> \fBTokenBucketX\fP< P >::\fBrate_type\fP"

.PP
The token rate type\&. 
.SS "template<typename P> typedef \fBTokenCounterX\fP<\fBrate_type\fP> \fBTokenBucketX\fP< P >::\fBcounter_type\fP"

.PP
The token counter type\&. 
.SS "template<typename P> typedef \fBrate_type::token_type\fP \fBTokenBucketX\fP< P >::\fBtoken_type\fP"

.PP
Unsigned type of token counts\&. 
.SS "template<typename P> typedef \fBrate_type::time_point_type\fP \fBTokenBucketX\fP< P >::\fBtime_point_type\fP"

.PP
Type of time ticks\&. 
.SS "template<typename P> typedef \fBrate_type::ticks_type\fP \fBTokenBucketX\fP< P >::\fBticks_type\fP"

.PP
Unsigned type of differences between time ticks\&. 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<typename P> \fBTokenBucketX\fP< P >::\fBTokenBucketX\fP ()\fC [inline]\fP"

.PP
Construct an idle token bucket\&. The initial time point is 0\&. 
.SS "template<typename P> \fBTokenBucketX\fP< P >::\fBTokenBucketX\fP (bool unlimited)\fC [inline]\fP, \fC [explicit]\fP"

.PP
Construct an idle or unlimited token bucket\&. 
.PP
\fBParameters:\fP
.RS 4
\fIunlimited\fP idle if false, unlimited if true
.RE
.PP
The initial time point is 0\&. 
.SS "template<typename P> \fBTokenBucketX\fP< P >::\fBTokenBucketX\fP (\fBtoken_type\fP rate, \fBtoken_type\fP capacity)\fC [inline]\fP"

.PP
Construct a token bucket representing \fIrate\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIrate\fP refill rate in tokens per period 
.br
\fIcapacity\fP maximum token accumulation
.RE
.PP
The initial time point is 0 and the token bucket is initially full (the initial token count equals \fIcapacity\fP)\&. The rate is idle if either \fIrate\fP or \fIcapacity\fP is 0\&.
.PP
\fBSee also:\fP
.RS 4
\fBassign\fP(\fI\fBrate\fP\fP, \fI\fBcapacity\fP\fP) 
.RE
.PP

.SH "Member Function Documentation"
.PP 
.SS "template<typename P> void \fBTokenBucketX\fP< P >::assign (bool unlimited = \fCfalse\fP)\fC [inline]\fP"

.PP
Set the token bucket rate to idle or unlimited\&. 
.PP
\fBParameters:\fP
.RS 4
\fIunlimited\fP idle if false, unlimited if true 
.RE
.PP

.SS "template<typename P> void \fBTokenBucketX\fP< P >::assign (\fBtoken_type\fP rate, \fBtoken_type\fP capacity)\fC [inline]\fP"

.PP
Set the token bucket rate and capacity\&. 
.PP
\fBParameters:\fP
.RS 4
\fIrate\fP refill rate in tokens per period 
.br
\fIcapacity\fP maximum token accumulation
.RE
.PP
Sets the token bucket's rate to \fIrate\fP and capacity to \fIcapacity\fP\&. If either \fIrate\fP or \fIcapacity\fP is 0, the token bucket becomes idle\&. The time point is unchanged\&.
.PP
The ratio of tokens/burst is unchanged by the assignment, so the actual number of tokens could go up or down, depending on how the rate is changed\&.
.PP
\fBSee also:\fP
.RS 4
\fBassign_adjust\fP 
.RE
.PP

.SS "template<typename P> void \fBTokenBucketX\fP< P >::assign_adjust (\fBtoken_type\fP rate, \fBtoken_type\fP capacity)\fC [inline]\fP"

.PP
Set the token bucket rate and capacity, preserving the token count\&. 
.PP
\fBParameters:\fP
.RS 4
\fIrate\fP refill rate in tokens per period 
.br
\fIcapacity\fP maximum token accumulation
.RE
.PP
This performs the same function as \fBassign()\fP, but additionally keeps the number of tokens roughly stable\&.
.PP
\fBSee also:\fP
.RS 4
\fBassign\fP 
.RE
.PP

.SS "template<typename P> bool \fBTokenBucketX\fP< P >::unlimited () const\fC [inline]\fP"

.PP
Return true iff the token rate is unlimited\&. 
.SS "template<typename P> bool \fBTokenBucketX\fP< P >::idle () const\fC [inline]\fP"

.PP
Return true iff the token rate is idle\&. 
.SS "template<typename P> \fBtoken_type\fP \fBTokenBucketX\fP< P >::rate () const\fC [inline]\fP"

.PP
Return the rate in tokens per period\&. Returns max_tokens for unlimited rates\&. Imprecise computer arithmetic may cause the result to differ from the configured rate\&. 
.SS "template<typename P> \fBtoken_type\fP \fBTokenBucketX\fP< P >::capacity () const\fC [inline]\fP"

.PP
Return the capacity in tokens\&. Returns max_tokens for unlimited rates\&. Imprecise computer arithmetic may cause the result to differ from the configured capacity\&. 
.SS "template<typename P> \fBtoken_type\fP \fBTokenBucketX\fP< P >::size () const\fC [inline]\fP"

.PP
Return the number of tokens in the bucket\&. The return value is a lower bound on the number of tokens, since \fBTokenBucketX\fP keeps track of fractional tokens\&. 
.SS "template<typename P> \fBtoken_type\fP \fBTokenBucketX\fP< P >::fraction () const\fC [inline]\fP"

.PP
Return the bucket's fullness fraction\&. The return value is a number between 0 and max_tokens, where max_tokens represents full capacity\&. 
.SS "template<typename P> bool \fBTokenBucketX\fP< P >::empty () const\fC [inline]\fP"

.PP
Test if the token bucket is completely empty\&. 
.SS "template<typename P> bool \fBTokenBucketX\fP< P >::full () const\fC [inline]\fP"

.PP
Test if the token bucket is at full capacity\&. 
.SS "template<typename P> bool \fBTokenBucketX\fP< P >::contains (\fBtoken_type\fP t) const\fC [inline]\fP"

.PP
Test if the token bucket has at least \fIt\fP tokens\&. Returns true whenever \fIt\fP is zero or \fIrate\fP is unlimited\&. Returns false whenever \fIt\fP is greater than \fIrate\&.capacity()\fP\&. 
.SS "template<typename P> bool \fBTokenBucketX\fP< P >::contains_fraction (\fBtoken_type\fP f) const\fC [inline]\fP"

.PP
Test if the token bucket is above a fraction of its capacity\&. 
.PP
\fBParameters:\fP
.RS 4
\fIf\fP fullness fraction, where max_tokens is full capacity 
.RE
.PP

.SS "template<typename P> void \fBTokenBucketX\fP< P >::clear ()\fC [inline]\fP"

.PP
Clear the token bucket\&. 
.PP
\fBSee also:\fP
.RS 4
\fBset()\fP, \fBset_full()\fP 
.RE
.PP

.SS "template<typename P> void \fBTokenBucketX\fP< P >::set_full ()\fC [inline]\fP"

.PP
Fill the token bucket to capacity\&. 
.PP
\fBSee also:\fP
.RS 4
\fBclear()\fP, \fBset()\fP 
.RE
.PP

.SS "template<typename P> void \fBTokenBucketX\fP< P >::set (\fBtoken_type\fP t)\fC [inline]\fP"

.PP
Set the token bucket to contain \fIt\fP tokens\&. 
.PP
\fBParameters:\fP
.RS 4
\fIt\fP number of tokens
.RE
.PP
The result will never have more tokens than the associated capacity\&. 
.SS "template<typename P> void \fBTokenBucketX\fP< P >::set_fraction (\fBtoken_type\fP f)\fC [inline]\fP"

.PP
Set the token bucket to a fraction of its capacity\&. 
.PP
\fBParameters:\fP
.RS 4
\fIf\fP fullness fraction, where max_tokens is full capacity 
.RE
.PP

.SS "template<typename P> void \fBTokenBucketX\fP< P >::refill ()\fC [inline]\fP"

.PP
Refill the token bucket to time P::now()\&. There are three \fBrefill()\fP methods, useful for different methods of measuring ticks\&. This method call parameter_type::now(), which returns the current time\&. Other methods use an explicit time point and a parameter_type::time(U) method\&.
.PP
\fBSee also:\fP
.RS 4
\fBset_time_point\fP 
.RE
.PP

.SS "template<typename P> void \fBTokenBucketX\fP< P >::refill (\fBtime_point_type\fP time)\fC [inline]\fP"

.PP
Refill the token bucket for \fItime\fP\&. 
.SS "template<typename P> template<typename U > void \fBTokenBucketX\fP< P >::refill (U time)\fC [inline]\fP"

.PP
Refill the token bucket for time P::time_point(\fItime\fP)\&. 
.SS "template<typename P> void \fBTokenBucketX\fP< P >::set_time_point (\fBtime_point_type\fP time)\fC [inline]\fP"

.PP
Set the token bucket's internal time point to \fItime\fP\&. Unlike \fBrefill()\fP, this method does not refill the counter\&.
.PP
\fBSee also:\fP
.RS 4
\fBrefill\fP 
.RE
.PP

.SS "template<typename P> void \fBTokenBucketX\fP< P >::remove (\fBtoken_type\fP t)\fC [inline]\fP"

.PP
Remove \fIt\fP tokens from the bucket\&. 
.PP
\fBParameters:\fP
.RS 4
\fIt\fP number of tokens
.RE
.PP
If the token bucket contains less than \fIt\fP tokens, the new token count is 0\&. 
.SS "template<typename P> bool \fBTokenBucketX\fP< P >::remove_if (\fBtoken_type\fP t)\fC [inline]\fP"

.PP
Remove \fIt\fP tokens from the bucket if it contains \fIt\fP tokens\&. 
.PP
\fBParameters:\fP
.RS 4
\fIt\fP number of tokens 
.RE
.PP
\fBReturns:\fP
.RS 4
true if \fIt\fP tokens were removed, false otherwise
.RE
.PP
If the token bucket contains \fIt\fP or more tokens, calls remove(\fIt\fP) and returns true\&. If it contains less than \fIt\fP tokens, returns false without removing any tokens\&. 
.SS "template<typename P> void \fBTokenBucketX\fP< P >::remove_fraction (\fBtoken_type\fP f)\fC [inline]\fP"

.PP
Remove a fullness fraction from the bucket\&. 
.PP
\fBParameters:\fP
.RS 4
\fIf\fP fullness fraction, where max_tokens is full capacity
.RE
.PP
If the token counter is less than \fIf\fP full, the new token count is 0\&. 
.SS "template<typename P> bool \fBTokenBucketX\fP< P >::remove_fraction_if (\fBtoken_type\fP f)\fC [inline]\fP"

.PP
Remove a fullness fraction from the bucket if it is full enough\&. 
.PP
\fBParameters:\fP
.RS 4
\fIf\fP fullness fraction, where max_tokens is full capacity 
.RE
.PP
\fBReturns:\fP
.RS 4
true if \fIf\fP was removed, false otherwise
.RE
.PP
If \fBfraction()\fP is at least \fIf\fP, calls remove_fraction(\fIf\fP) and returns true\&. Otherwise, returns false without removing any tokens\&. 
.SS "template<typename P> \fBticks_type\fP \fBTokenBucketX\fP< P >::time_until_contains (\fBtoken_type\fP t) const\fC [inline]\fP"

.PP
Return the number of ticks until contains(\fIt\fP)\&. Returns (ticks_type) -1 if passing time will never make contains(\fIt\fP) true\&. 
.SS "template<typename P> \fBticks_type\fP \fBTokenBucketX\fP< P >::time_until_contains_fraction (\fBticks_type\fP f) const\fC [inline]\fP"

.PP
Return the number of ticks until contains_fraction(\fIf\fP)\&. Returns (ticks_type) -1 if passing time will never make contains_fraction(\fIf\fP) true\&. 

.SH "Author"
.PP 
Generated automatically by Doxygen for Click from the source code\&.
